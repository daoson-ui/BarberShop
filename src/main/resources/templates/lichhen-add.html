<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Th√™m L·ªãch h·∫πn</title>

    <style>
        body {
            font-family: Arial;
            background: #f5f5f5;
            padding: 30px;
        }

        .container {
            width: 450px;
            margin: auto;
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 0 10px #ccc;
        }

        h2 { text-align: center; margin-bottom: 20px; }

        label {
            font-weight: bold;
            margin-top: 10px;
            display: block;
        }

        input, select {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            border: 1px solid #ccc;
            border-radius: 6px;
        }

        .dv-box {
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 6px;
            max-height: 180px;
            overflow-y: auto;
            background: #fafafa;
            margin-bottom: 15px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 15px;
            cursor: pointer;
        }

        .button {
            display: block;
            text-align: center;
            padding: 10px;
            margin-top: 15px;
            border-radius: 6px;
            background: #555;
            color: white;
            text-decoration: none;
        }

        .alert-error {
            color: red;
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
        }

        /* gi·ªù b·∫≠n */
        .busy-option {
            background: #ffcccc !important;
            color: #555 !important;
            font-weight: bold;
        }

        /* gi·ªù r·∫£nh */
        .free-option {
            background: #eeffee !important;
            font-weight: bold;
        }
    </style>
</head>
<body>

<div class="container">
    <h2>Th√™m L·ªãch h·∫πn</h2>

    <div th:if="${errorMsg}" class="alert-error" th:text="${errorMsg}"></div>

    <form th:action="@{/user/lichhen/save}" method="post" id="addForm">
        <!-- D·ªãch v·ª• -->
        <label>D·ªãch v·ª•:</label>
        <div class="dv-box">
            <label th:each="dv : ${listDichVu}" style="display:block; margin-bottom:5px;">
                <input type="checkbox" name="dichVuChon"
                       th:value="${dv.maDv}"/>
                <span th:text="${dv.tenDv}"></span>
            </label>
        </div>

       
        
        <!-- Nh√¢n vi√™n -->
        <label>Nh√¢n vi√™n:</label>
        <select name="manv" id="manv" required>
            <option value="">-- Ch·ªçn nh√¢n vi√™n --</option>
            <option th:each="nv : ${listNhanVien}"
                    th:value="${nv.manv}"
                    th:text="${nv.hoTen}">
            </option>
        </select>
        <!-- Ng√†y h·∫πn -->
        <label>Ng√†y h·∫πn:</label>
        <input type="date" name="ngayHen" id="ngayHen" required/>

        <!-- Gi·ªù h·∫πn -->
        <label>Gi·ªù h·∫πn:</label>
        <select name="gioHen" id="gioHen" required>
            <option value="">-- Ch·ªçn gi·ªù --</option>
        </select>

        <button type="submit">üíæ ƒê·∫∑t l·ªãch h·∫πn</button>
    </form>

    <a href="/user/home" class="button">‚Üê Quay l·∫°i</a>
</div>

<script>
/*
 Advanced timeslot loader
 - Debounce (300ms)
 - Abort previous fetch to avoid races
 - Cache by key (manv|ngay|dvIdsKey)
 - Preserve selected services regardless ch·ªçn theo th·ª© t·ª± n√†o
 - Show simple loading state and handle network errors
 - Works with checkboxes name="dichVuChon", inputs: #ngayHen, #manv, <select id="gioHen">
*/

(() => {
    const DEBOUNCE_MS = 300;
    const MIN_SLOT = "-- Ch·ªçn gi·ªù --";

    const ngayEl = document.getElementById('ngayHen');
    const manvEl = document.getElementById('manv');
    const gioEl = document.getElementById('gioHen');
    const formEl = document.getElementById('addForm');
    const dvSelectorName = "dichVuChon";

    // cache map: key -> data
    const cache = new Map();

    // abort controller for in-flight fetch
    let currentAbort = null;

    // simple debounce helper
    function debounce(fn, ms) {
        let t = null;
        return (...args) => {
            if (t) clearTimeout(t);
            t = setTimeout(() => fn(...args), ms);
        };
    }

    // build canonical key for dvIds (sorted numeric)
    function dvIdsKey(arr) {
        if (!arr || arr.length === 0) return "";
        // ensure numbers and sorted to keep stable key regardless order of selection
        const normalized = arr.map(x => String(x)).sort();
        return normalized.join(',');
    }

    // read currently checked dv ids (live)
    function readSelectedDvIds() {
        const nodeList = document.querySelectorAll(`input[name='${dvSelectorName}']:checked`);
        const ids = Array.from(nodeList).map(n => n.value).filter(v => v !== undefined && v !== null && v !== "");
        return ids;
    }

    // helper to set spinner in select
    function showLoading() {
        gioEl.innerHTML = "";
        const o = document.createElement('option');
        o.value = "";
        o.textContent = "ƒêang t·∫£i...";
        o.disabled = true;
        gioEl.appendChild(o);
    }

    function resetSelect() {
        gioEl.innerHTML = "";
        const o = document.createElement('option');
        o.value = "";
        o.textContent = MIN_SLOT;
        gioEl.appendChild(o);
    }

    function setError(msg) {
        resetSelect();
        const o = document.createElement('option');
        o.value = "";
        o.textContent = "L·ªói: " + msg;
        o.disabled = true;
        gioEl.appendChild(o);
    }

    // render data into select
    function renderSlots(data) {
        // data is array of {time: "08:00", busy: true/false}
        gioEl.innerHTML = "";
        const defaultOpt = document.createElement('option');
        defaultOpt.value = "";
        defaultOpt.textContent = MIN_SLOT;
        gioEl.appendChild(defaultOpt);

        data.forEach(item => {
            const opt = document.createElement('option');
            opt.value = item.time;
            opt.textContent = item.busy ? `${item.time} (B·∫≠n)` : item.time;
            if (item.busy) {
                opt.disabled = true;
                opt.className = "busy-option";
            } else {
                opt.className = "free-option";
            }
            gioEl.appendChild(opt);
        });
    }

    // Actual loader (non-debounced)
    async function _loadTimeSlots() {
        const ngay = ngayEl.value;
        const manv = manvEl.value;

        // if missing ngay or manv -> reset select and STOP
        if (!ngay || !manv) {
            resetSelect();
            return;
        }

        // get dv ids (always read live)
        const dvIds = readSelectedDvIds();
        const dvKey = dvIdsKey(dvIds);
        const cacheKey = `${manv}|${ngay}|${dvKey}`;

        // if cached, use it
        if (cache.has(cacheKey)) {
            renderSlots(cache.get(cacheKey));
            return;
        }

        // abort previous fetch if any
        if (currentAbort) {
            try { currentAbort.abort(); } catch (e) {/* no-op */}
            currentAbort = null;
        }
        currentAbort = new AbortController();
        const signal = currentAbort.signal;

        showLoading();

        // build url param safely (encode)
        const params = new URLSearchParams();
        params.set('manv', String(manv));
        params.set('ngay', String(ngay));
        // append dvIds[] multiple times
        dvIds.forEach(id => params.append('dvIds[]', String(id)));

        const url = `/user/lichhen/api/timeslots?${params.toString()}`;

        try {
            const res = await fetch(url, { signal, cache: 'no-store' });
            if (!res.ok) {
                // network error code path
                setError(`Server tr·∫£ l·ªói ${res.status}`);
                return;
            }
            const data = await res.json();

            // basic validation
            if (!Array.isArray(data)) {
                setError("D·ªØ li·ªáu tr·∫£ v·ªÅ kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng");
                return;
            }

            // cache result (small LRU not needed for small app)
            cache.set(cacheKey, data);

            renderSlots(data);

        } catch (err) {
            if (err.name === 'AbortError') {
                // intentionally aborted - do nothing
                return;
            }
            // network/other error
            setError("Kh√¥ng th·ªÉ k·∫øt n·ªëi. Vui l√≤ng th·ª≠ l·∫°i.");
            console.error("loadTimeSlots error:", err);
        } finally {
            currentAbort = null;
        }
    }

    // debounced loader for event handlers
    const loadTimeSlots = debounce(_loadTimeSlots, DEBOUNCE_MS);

    // Attach events:
    // - change on date and staff
    // - change on any dv checkbox
    // - also on page load (in case fields prefilled)
    function wireEvents() {
        if (ngayEl) ngayEl.addEventListener('change', loadTimeSlots);
        if (manvEl) manvEl.addEventListener('change', loadTimeSlots);

        // delegate: new checkboxes might be added; we wire current ones and observe container if needed
        document.querySelectorAll(`input[name='${dvSelectorName}']`).forEach(cb => {
            cb.addEventListener('change', loadTimeSlots);
        });

        // if someone programmatically changes selections, you may call loadTimeSlots() manually

        // on form submit, final client-side check for past datetime
        if (formEl) {
            formEl.addEventListener('submit', (e) => {
                const date = ngayEl.value;
                const time = gioEl.value;
                if (!date || !time) return; // let server validate too
                const selected = new Date(date + "T" + time);
                const now = new Date();
                if (selected < now) {
                    e.preventDefault();
                    alert("‚ùå Kh√¥ng th·ªÉ ƒë·∫∑t l·ªãch trong qu√° kh·ª©!");
                }
            });
        }
    }

    // Run at init
    wireEvents();

    // Optional: load slots if fields already prefilled (e.g. user navigated back)
    // Delay a tick to allow any server-side prefill to render
    setTimeout(() => {
        _loadTimeSlots().catch(e => console.warn("init loadTimeSlots error", e));
    }, 100);

    // Expose for debug if needed
    window.__barbershop_timeslot = {
        load: _loadTimeSlots,
        cacheClear: () => cache.clear()
    };

})();
</script>


</body>
</html>
